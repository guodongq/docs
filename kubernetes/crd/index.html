<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Bruce Qian" /><link rel="canonical" href="https://guodongq.github.io/docs/kubernetes/crd/" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>编写Kubernetes CRD扩展Kubernetes API - Bruce's Notebook</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
        <link href="../../css/extra.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "\u7f16\u5199Kubernetes CRD\u6269\u5c55Kubernetes API";
        var mkdocs_page_input_path = "kubernetes/crd.md";
        var mkdocs_page_url = "/docs/kubernetes/crd/";
      </script>
    
    <script src="../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/yaml.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/django.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> Bruce's Notebook
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">K8S</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../extend/">Kubernetes扩展</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">编写Kubernetes CRD扩展Kubernetes API</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#_1">声明式编程</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#gvkgvr">GVK&amp;&amp;GVR</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_2">控制器模式</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_3">开发脚手架</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#operator-sdk-getting-started">Operator SDK Getting Started</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_4">安装依赖</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_5">创建脚手架工程</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#api">创建API</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#crd">定义CRD</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#controller">编写Controller逻辑</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_6">测试发布</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#local-debug">Local Debug</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_7">总结</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#operator-sdkcrd">operator-sdk编写crd的流程</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_8">如何自定义显示列?</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#rbac">如何通过rbac添加权限？</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_9">如何对字段添加校验?</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#reconcile">Reconcile方法什么时候被调度?</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#reconcile_1">Reconcile方法什么时候被再次调度?</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#crcr">当删除CR资源时，被CR管理的其他资源怎样同时被删除?</a>
    </li>
        </ul>
    </li>
    </ul>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">CSAPP</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../csapp/">深入理解计算机系统</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">Bruce's Notebook</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>K8S &raquo;</li><li>编写Kubernetes CRD扩展Kubernetes API</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>

          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="kubernetes-crdkubernetes-api">编写Kubernetes CRD扩展Kubernetes API<a class="headerlink" href="#kubernetes-crdkubernetes-api" title="Permanent link"></a></h1>
<h2 id="_1">声明式编程<a class="headerlink" href="#_1" title="Permanent link"></a></h2>
<ul>
<li>命令式编程：详细的命令机器怎么(How)去处理一件事情以达到你想要的结果(What)  </li>
<li>声明式编程：只告诉你想要的结果(What)，机器自己摸索过程(How)  </li>
</ul>
<p>在Kubernetes中一般会编写对应API对象的YAML文件交给Kubernetes(而不是使用一些命令来直接操作API)，即只需要提交一个定义好的API对象来"声明"（这个YAML文件其实就是一种"声明"),表示所期望的最终状态是什么样子就可以了</p>
<p>用户只需要关心应用程序的最终状态，其他的都是通过K8s来帮助我们完成，通过这种声明式的方式可以大大简化应用的配置管理复杂度</p>
<h2 id="gvkgvr">GVK&amp;&amp;GVR<a class="headerlink" href="#gvkgvr" title="Permanent link"></a></h2>
<p>在Kubernetes中想要完成一个CRD，需要指定 <code>group/version</code> 和 <code>kind</code>, 在kuberntes的API Server中简称为GVK，GVK是定位一种类型的方式，例如daemonsets就是Kubernetes的一种资源，当我们想要通过Kubernetes创建一个daemonsets的时候，需要定义daemonsets的描述文件</p>
<pre><code>apiVersion: apps/v1 
kind: DaemonSet
</code></pre>
<p>这里声明了apiVersion是 <code>apps/v1</code>,其实隐含了Group是apps，Version是v1，Kind是定义的DaemonSet，而kubectl接收到这个声明以后，可以根据这个声明去调用API Server对应的URL去获取信息，本例中就是 <code>/apis/apps/v1/daemonset</code></p>
<p>Kubernetes组织资源的方式是以REST的URI形式的，而组织的路径就是：</p>
<p><img alt="Kubernetes GVR" src="../../assets/images/gvr.jpg" /></p>
<p>在API Server中还有第二个概念GVR, 当我们理解了GVK之后，再来理解GVR就容易了，和面向对象编程中的类和对象的概念是一样的</p>
<table>
<thead>
<tr>
<th>Kubernetes</th>
<th>OOP</th>
</tr>
</thead>
<tbody>
<tr>
<td>Kind</td>
<td>Class</td>
</tr>
<tr>
<td>Resource</td>
<td>Object</td>
</tr>
</tbody>
</table>
<p>Kind其实就是一个类，用于描述对象的，而Resource就是具体的Kind，可以理解成类已经实例化成对象了</p>
<h2 id="_2">控制器模式<a class="headerlink" href="#_2" title="Permanent link"></a></h2>
<p>kubernetes作为一个“容器编排”平台，其核心的功能是编排，Pod作为K8s调度的最小单位，具备很多属性和字段，k8s编排正是通过一个个控制器根据被控制对象的属性和字段来实现。</p>
<p>K8s集群在部署时包含了Controllers组件，里面对于每个build-in的资源类型（比如Deployment、Statefulset、Cronjob…）都有对应的Controller，基本是1:1的关系</p>
<pre><code>apiVersion: apps/v1 
kind: Deployment 
metadata: 
  name: test 
spec: 
  selector:
    matchLabels:
      app: test
  replicas: 2
  template:
    metadata:
      labels:
        app: test
    spec:
      containers:
      - name: nginx
        image: nginx:1.7.9
        ports:
        - containerPort: 80
</code></pre>
<p>如上，Deployment资源创建以后，对应的Deployment Controller确保当前的deployment资源的Pod个数永远为2，Pod由Template部分组成,具体来说K8s里面的kube-controller-manager这个组件在做这件事情，在 <code>kubernetes/pkg/controller</code> 目录下包含了所有的控制器，它们都以独有的方式负责某种编排功能，但是它们都遵循一个通用的编排模式，即：调谐循环(Reconcile loop),伪代码逻辑如下:</p>
<pre><code>for {
 actualState := GetResourceActualState(rsvc) 
 expectState := GetResourceExpectState(rsvc)
 if actualState == expectState {
    // do nothing
 } else {
    Reconcile(rsvc)
 }
}
</code></pre>
<ul>
<li>就是一个无限循环不断地对比期望状态和实际状态，如果有出入则进行Reconcile(调谐)逻辑将实际状态调整为期望状态  </li>
<li>期望状态就是我们对象的定义(通常是YAML文件),实际状态是k8s集群里面当前的运行状态  </li>
<li>控制器的编排逻辑主要是第三步做的，这个操作称为调谐(Reconcile),整个控制器的调谐过程称为"Reconcile Loop"</li>
</ul>
<h2 id="_3">开发脚手架<a class="headerlink" href="#_3" title="Permanent link"></a></h2>
<ul>
<li><a href="https://github.com/kubernetes/code-generator">code-generator</a></li>
<li><a href="https://github.com/kubernetes-sigs/kubebuilder">kubebuilder</a></li>
<li><a href="https://github.com/operator-framework/operator-sdk">operator-sdk</a></li>
</ul>
<p><code>code-generator</code> 实际上并不能称之为crd开发的脚手架，它只是能生成一些代码，如果用code-generator进行crd的开发需要手工编写很多代码</p>
<p><code>kubebuilder</code> 和 <code>operator-sdk</code> 都是为了方便创建和管理operator而生的脚手架项目, <code>operator-sdk</code> 在底层使用了 <code>kubebuilder</code>,两者在创建operator项目时都是调用 <code>controller-runtime</code> 接口，具有相同的项目布局。</p>
<p>除此之外 <code>operator-sdk</code> 还增加了一些特性，具体可以 <a href="https://sdk.operatorframework.io/docs/faqs/">参考</a></p>
<ul>
<li>两者不是竞争关系, <code>operator-sdk</code> 相当于是 <code>kubebuilder+</code>  </li>
<li><code>operator-sdk</code> 的文档质量高，感觉 <code>operator-sdk</code> 更像是商业版本的kubebuilder,实际上它们都是开源的 </li>
</ul>
<h2 id="operator-sdk-getting-started">Operator SDK Getting Started<a class="headerlink" href="#operator-sdk-getting-started" title="Permanent link"></a></h2>
<h3 id="_4">安装依赖<a class="headerlink" href="#_4" title="Permanent link"></a></h3>
<p>在开发CRD之前，需要安装一些工具，具体的可以 <a href="https://sdk.operatorframework.io/docs/building-operators/golang/installation/#additional-prerequisites">参考</a> </p>
<ul>
<li>operator-sdk  </li>
<li>git  </li>
<li>go  </li>
<li>docker  </li>
<li>kubectl  </li>
</ul>
<h3 id="_5">创建脚手架工程<a class="headerlink" href="#_5" title="Permanent link"></a></h3>
<pre><code>❯ mkdir mario
❯ cd mario
❯ pwd
/Users/qianguodong/Projects/src/github.com/guodongq/mario

❯ operator-sdk init --domain qgd.io --repo github.com/guodongq/mario

Writing kustomize manifests for you to edit...
Writing scaffold for you to edit...
Get controller runtime:
$ go get sigs.k8s.io/controller-runtime@v0.10.0
Update dependencies:
$ go mod tidy
Next: define a resource with:
$ operator-sdk create api

❯ tree -L 2
.
├── Dockerfile
├── Makefile
├── PROJECT
├── config
│   ├── default
│   ├── manager
│   ├── manifests
│   ├── prometheus
│   ├── rbac
│   └── scorecard
├── go.mod
├── go.sum
├── hack
│   └── boilerplate.go.txt
└── main.go

8 directories, 7 files
</code></pre>
<p>执行上面的命令后会生成基本的目录结构，对其中的每个目录解释如下</p>
<ul>
<li>Dockerfile 用于构建Docker镜像  </li>
<li>Makefile  编译、构建、部署operator都会用到该文件  </li>
<li>PROJECT 工程的元数据，在生成各种API的时候会用到这里面的信息</li>
<li>config/default 基于kustomize制作的配置文件，为controller提供标准配置，也可以根据需要去修改调整  </li>
<li>config/manager 和controller有关的细节配置，例如镜像的资源限制  </li>
<li>config/manifests 基于kustomize方式管理operator生成的所有manifest</li>
<li>config/rbac operator在kubernetes中的操作权限，通过rbac做精细的权限配置  </li>
<li>config/scorecard 工具用来验证operator打包并运行测试  </li>
<li>go.mod go语言依赖  </li>
<li>hack/boilerplate.go.txt 生成的文件头部添加的license  </li>
<li>main.go 主函数</li>
</ul>
<h3 id="api">创建API<a class="headerlink" href="#api" title="Permanent link"></a></h3>
<pre><code>❯ operator-sdk create api --group mario.horizon --version v1 --kind Pipeline --resource --controller
Writing kustomize manifests for you to edit...
Writing scaffold for you to edit...
api/v1/pipeline_types.go
controllers/pipeline_controller.go
Update dependencies:
$ go mod tidy
Running make:
$ make generate
go: creating new go.mod: module tmp
Downloading sigs.k8s.io/controller-tools/cmd/controller-gen@v0.7.0
go get: installing executables with 'go get' in module mode is deprecated.
    To adjust and download dependencies of the current module, use 'go get -d'.
    To install using requirements of the current module, use 'go install'.
    To install ignoring the current module, use 'go install' with a version,
    like 'go install example.com/cmd@latest'.
    For more information, see https://golang.org/doc/go-get-install-deprecation
    or run 'go help get' or 'go help install'.
go get: added github.com/fatih/color v1.12.0
go get: added github.com/go-logr/logr v0.4.0
go get: added github.com/gobuffalo/flect v0.2.3
go get: added github.com/gogo/protobuf v1.3.2
go get: added github.com/google/go-cmp v0.5.6
go get: added github.com/google/gofuzz v1.1.0
go get: added github.com/inconshreveable/mousetrap v1.0.0
go get: added github.com/json-iterator/go v1.1.11
go get: added github.com/mattn/go-colorable v0.1.8
go get: added github.com/mattn/go-isatty v0.0.12
go get: added github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd
go get: added github.com/modern-go/reflect2 v1.0.1
go get: added github.com/spf13/cobra v1.2.1
go get: added github.com/spf13/pflag v1.0.5
go get: added golang.org/x/mod v0.4.2
go get: added golang.org/x/net v0.0.0-20210520170846-37e1c6afe023
go get: added golang.org/x/sys v0.0.0-20210616094352-59db8d763f22
go get: added golang.org/x/text v0.3.6
go get: added golang.org/x/tools v0.1.5
go get: added golang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1
go get: added gopkg.in/inf.v0 v0.9.1
go get: added gopkg.in/yaml.v2 v2.4.0
go get: added gopkg.in/yaml.v3 v3.0.0-20210107192922-496545a6307b
go get: added k8s.io/api v0.22.2
go get: added k8s.io/apiextensions-apiserver v0.22.2
go get: added k8s.io/apimachinery v0.22.2
go get: added k8s.io/klog/v2 v2.9.0
go get: added k8s.io/utils v0.0.0-20210819203725-bdf08cb9a70a
go get: added sigs.k8s.io/controller-tools v0.7.0
go get: added sigs.k8s.io/structured-merge-diff/v4 v4.1.2
go get: added sigs.k8s.io/yaml v1.2.0
/Users/qianguodong/Projects/src/github.com/guodongq/mario/bin/controller-gen object:headerFile=&quot;hack/boilerplate.go.txt&quot; paths=&quot;./...&quot;
Next: implement your new API and generate the manifests (e.g. CRDs,CRs) with:
$ make manifests
</code></pre>
<p>项目中自动增加了很多内容，如下图所示</p>
<p><img alt="Kubernetes CRD API" src="../../assets/images/crd-api.jpg" /></p>
<ul>
<li>新增加的内容中，最核心的是CRD了，也就是上图中Pipeline数据结构所在的 <code>pipeline_types.go</code>, 这个最重要的数据结构如下</li>
</ul>
<pre><code>// Pipeline is the Schema for the pipelines API
type Pipeline struct {
  metav1.TypeMeta   `json:&quot;,inline&quot;`
  metav1.ObjectMeta `json:&quot;metadata,omitempty&quot;`

  Spec   PipelineSpec   `json:&quot;spec,omitempty&quot;`
  Status PipelineStatus `json:&quot;status,omitempty&quot;`
}
</code></pre>
<ul>
<li>metav1.TypeMeta: 保存资源的Group、Version、Kind  </li>
<li>metav1.ObjectMeta: 保存资源对象的名称和namespace  </li>
<li>Spec: 期望状态  </li>
<li>Status: 实际状态  </li>
<li>还有一个数据结构就是Pipeline对应的列表PipelineList,就是单个资源对象的集合</li>
</ul>
<h3 id="crd">定义CRD<a class="headerlink" href="#crd" title="Permanent link"></a></h3>
<p>在operator-sdk生成的项目结构中的 <code>pipeline_types.go</code> 文件中定义Spec和Status</p>
<h3 id="controller">编写Controller逻辑<a class="headerlink" href="#controller" title="Permanent link"></a></h3>
<p>在operator-sdk生成的项目结构中的 <code>pipeline_controller.go</code> 文件中实现Reconcile的逻辑</p>
<h3 id="_6">测试发布<a class="headerlink" href="#_6" title="Permanent link"></a></h3>
<p>本地调试以后，可以使用Makefile构建镜像，部署我们的CRDs和Controller即可</p>
<ul>
<li>make docker-build IMG=imbruce/mario:v1.0.23</li>
<li>make docker-push IMG=imbruce/mario:v1.0.23  </li>
<li>make deploy IMG=imbruce/mario:v1.0.23</li>
</ul>
<h3 id="local-debug">Local Debug<a class="headerlink" href="#local-debug" title="Permanent link"></a></h3>
<p>CRD controller是通过API Server来观察ETCD中CR资源的变化产生的事件，从而进行Reconcile调谐逻辑，实际上我们可以在本地进行crd controller的调试</p>
<p>当需要在本地进行调试时，需要做如下步骤</p>
<ul>
<li>export KUBECONFIG=***  指定使用的k8s的kubeconfig文件  </li>
<li>make install  将CRD定义安装到Kubernetes Cluster之中</li>
<li>本地启动crd controller即可</li>
</ul>
<h2 id="_7">总结<a class="headerlink" href="#_7" title="Permanent link"></a></h2>
<h3 id="operator-sdkcrd">operator-sdk编写crd的流程<a class="headerlink" href="#operator-sdkcrd" title="Permanent link"></a></h3>
<ul>
<li>使用operator-sdk创建一个新的Operator项目  </li>
<li>添加自定义资源(CRD)定义新的资源API  </li>
<li>丰富完善CRD的结构定义</li>
<li>定义Operator的调谐(reconcile)逻辑  </li>
<li>使用Operator SDK构建并生成Operator部署清单文件  </li>
<li>部署CRD到Kubernetes Cluster中</li>
</ul>
<h3 id="_8">如何自定义显示列?<a class="headerlink" href="#_8" title="Permanent link"></a></h3>
<p>从1.11以后, <code>kubectl get</code> 可以增加显示的列,通过标记 <code>+kubebuilder:printcolumn</code> 进行添加</p>
<h3 id="rbac">如何通过rbac添加权限？<a class="headerlink" href="#rbac" title="Permanent link"></a></h3>
<p>如下图Reconcile方法前面有一些  <code>+kubebuilder:rbac</code> 的前缀，这些是用来确保controller在运行时有相应的资源操作权限</p>
<p><img alt="Kubernetes RBAC" src="../../assets/images/rbac.jpg" /></p>
<h3 id="_9">如何对字段添加校验?<a class="headerlink" href="#_9" title="Permanent link"></a></h3>
<p>使用注解 <code>+kubebuilder:validation:***</code> 对需要的字段添加校验规则,具体可以 <a href="https://book.kubebuilder.io/reference/markers/crd-validation.html">参考</a></p>
<h3 id="reconcile">Reconcile方法什么时候被调度?<a class="headerlink" href="#reconcile" title="Permanent link"></a></h3>
<ul>
<li>For: 当监控的资源发生变化时  </li>
<li>Owns: 当从属的资源发生变化时</li>
</ul>
<p><img alt="Kubernetes Reconcile Scheduler" src="../../assets/images/reconcile-scheduler.jpg" /></p>
<h3 id="reconcile_1">Reconcile方法什么时候被再次调度?<a class="headerlink" href="#reconcile_1" title="Permanent link"></a></h3>
<p>通过查看Reconcile的源码，发现当如下条件发生时，reconcile方法会被再次调度起来  </p>
<ul>
<li>返回错误： return reconcile.Result{}, err  </li>
<li>没有error，显式指定放到队列中: return reconcile.Result{Requeue: true}, nil  </li>
<li>没有error，显式指定下一次触发的时间，一般用在cronjob中： return reconcile.Result{RequeueAfter: time.Second}, nil  </li>
</ul>
<p>PS: 如果想要终止Reconcile逻辑，请返回 return reconcile.Result{}, nil</p>
<p><img alt="Kubernetees Reconcile" src="../../assets/images/reconcile.jpg" /></p>
<h3 id="crcr">当删除CR资源时，被CR管理的其他资源怎样同时被删除?<a class="headerlink" href="#crcr" title="Permanent link"></a></h3>
<p>当我们创建一种资源的时候，顺带着会创建一些其他的资源，例如 eployment会创建Replicaset，replicaset会创建Pod<br />
当我们删除某种资源时，其他顺带创建的资源也一并删除，使用OwnReference进行垃圾清理</p>
<p><img alt="Kubernetes OwnReference" src="../../assets/images/ownreference.jpg" /></p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../extend/" class="btn btn-neutral float-left" title="Kubernetes扩展"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../../csapp/" class="btn btn-neutral float-right" title="深入理解计算机系统">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
      <p>Copyright &copy; 2020 - 2022 Bruce Qian</p>
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../extend/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../../csapp/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
